** 데이터베이스 3일차

## join 조인 

- 두개 이상의 테이블에서 데이터를 검색하기 위해. 

문제> 'king' 의 부서 이름을 출력하라.

```
 select employee_id, department_id
	from employees
	where last_name = 'King';
	

 select department_id, department_name
	from departments
	where department_id IN(80,90);
	
```	


=> 조인 이용 방법 
1. 내가 원하는 데이터는 무엇인가? (컬럼 목록)
2. 원하는 데이터가 어느 테이블에 있는가?
3. 여러 테이블에 있다면 각각의 테이블에 공통 컬럼을 찾는다.



```
	SELECT e.employee_id, e.department_id, d.department_name
	FROM employees e, departments d
	WHERE e.department_id = d.department_id
	AND last_name = 'King';
```


######퀴즈01> '송강' 교수가 강의하는 과목을 검색해라. 1. 교수번호 (pno) 2. 교수이름 (pname) 3. 과목명(cname)

```
	SELECT p.pno, p.pname, c.cname
	FROM professor p, course c
	WHERE p.pno = c.pno
	AND pname = '송강';
```


---1. 학점이 2학점인 과목과 이를 강의하는 교수를 검색해라. <br/>
---2. 화학과 1학년 학생의 기말고사 성적을 검색해라. <br/>
---3. 화학과 1학년 학생이 수강하는 과목을 검색해라(3개 테이블 조인) <br/>


```
	SELECT c.cname, c.st_num, p.pname
	FROM course c, professor p
	WHERE c.pno = p.pno
	AND c.st_num = 2;
	
	
	SELECT s.syear, s.major, s.sname, ss.result
	FROM student s, score ss
	WHERE s.sno = ss.sno
	AND s.major = '화학'
	AND s.syear = 1;
	
	
	SELECT s.syear, s.major, s.sname, c.cname
	FROM student s, score ss, course c
	WHERE s.sno = ss.sno
	AND ss.cno = c.cno
	AND s.major = '화학'
	AND s.syear = 1; 
 
```


조인이 많아질수록 WHERE 절이 많아지게 됨..

=> ANSI JOIN(SQL-99)

```
	(이전)
	
	SELECT e.employee_id, e.department_id, d.department_name
	FROM employees e, departments d
	WHERE e.department_id = d.department_id
	AND last_name = 'King';
```

```
	(이후)
	SELECT e.employee_id, e.department_id, d.department_name
	FROM employees e INNER JOIN departments d
	ON e.department_id = d.department_id
	WHERE last_name = 'King';

```


-> 3개 이상 조인

- 테이블1 JOIN 테이블2
	ON 공통컬럼1 = 공통컬럼1
	JOIN 테이블3
	ON 공통컬럼2 = 공통컬럽2


	
--퀴즈: 3개 이상 테이블을 조인해
--(사원이름, 이메일, 부서번호, 부서이름, 직종번호(job_id), 직종이름(JOB_TITLE)을 출력해보자.
-- WHERE , ANSI 

```
SELECT e.employee_id, e.email, e.department_id, d.department_name, j.job_id, j.job_title
FROM employees e, departments d, jobs j
WHERE e.department_id = d.department_id
AND e. job_id = j.job_id;
```

```
SELECT e.employee_id, e.email, e.department_id, d.department_name, j.job_id, j.job_title
FROM employees e 
INNER JOIN departments d
ON e.department_id = d.department_id
INNER JOIN jobs j
ON e.job_id = j.job_id;
```

-- 'Seattle' (city) 에 근무하는 사원이름, 부서번호, 직종번호, 직종이름, 도시이름 출력하다. <br/>
-- (where, ansi)

```
SELECT  e.employee_id, e.first_name, e.department_id, e.job_id, j.job_title, l.city
FROM employees e, jobs j, departments d, locations l
where e.job_id = j.job_id
AND e.department_id = d.department_id
AND d.location_id = l.location_id
AND l.city = 'Seattle';


SELECT  e.employee_id, e.first_name, e.department_id, e.job_id, j.job_title, l.city
FROM employees e
INNER JOIN jobs j
ON e.job_id = j.job_id
INNER JOIN departments d
ON e.department_id = d.department_id
INNER JOIN locations l
ON d.location_id = l.location_id
WHERE l.city = 'Seattle';

```



## Self JOIN
'Kochhar' 직속상사의 정보를 출력해라. <br/>
자기 테이블의 특정 컬럼을 참조할 때 <br/>
논리적으로 하나의 테이블을 더 생각해보면 됨 <br/>

```
SELECT A.last_name || '의 매니저는' || B.last_name || '이다.'
FROM employees A, employees B
WHERE A.manager_id = B.employee_id
AND A.last_name = 'Kochhar';

```


-- 퀴즈 > kosa01 학생 중에 동명이인을 검색해라. 
 
``` 
 SELECT distinct A.sname, A.sno, B.sname, B.sno
 FROM student A, student B
 WHERE A.sname = B.sname
 AND A.sno != B.sno;

```

### OUTER JOIN(외부조인)


```
SELECT * FROM employees; => 50rows

SELECT e.employee_id, e.department_id, d.department_name
FROM employees e, departments d
WHERE e.department_id = d.department_id;

```

조인을 하면 누락된 데이터가 나올 수 있음. department_id 가 없으면 안나옴 <br/>
데이터값이 널이어도 전체데이터를 다 출력하기 위해 outer join 을 사용하는 것임  <br/>


```
(Outer JOIN 적용)

SELECT e.employee_id, e.department_id, d.department_name
FROM employees e, departments d
WHERE e.department_id = d.department_id(+);
//데이터값 누락된 반대에 + 를 한다.

```

-ANSI JOIN

```
SELECT e.employee_id, e.department_id, d.department_name
FROM employees e LEFT JOIN departments d
ON e.department_id = d.department_id;
// 누락된 방향이 왼쪽이면 LEFT 누락된 방향이 오른쪽이면 RIGHT
```


-- 퀴즈 kosa1> 등록된 과목에 대한 모든 교수를 검색해라(등록하지 않은 교수도 출력, 누락된 교수가 없도록)

```
--36
 SELECT * FROM professor;

 
 --29
 SELECT p.pname, c.cname
 FROM professor p, course c
 WHERE p.pno = c.pno;
 
 ```
#### OUTER JOIN <professor 기준>
 
 ```
 SELECT p.pname, c.cname
 FROM professor p, course c
 WHERE p.pno = c.pno(+);
 
 
 SELECT p.pname, c.cname
 FROM professor p LEFT JOIN course c
 ON p.pno = c.pno;
 
 ```
 
#### OUTER JOIN <course 기준>
  
  ```
  --32 
 SELECT * FROM course;
 

 SELECT p.pname, c.cname
 FROM professor p, course c
 WHERE p.pno(+) = c.pno;
 
 
 SELECT p.pname, c.cname
 FROM professor p RIGHT JOIN course c
 ON p.pno = c.pno;
 
 ```
 
#### 양쪽 다 누락됐을 경우 
 
 ```
 SELECT p.pname, c.cname
 FROM professor p FULL JOIN course c
 ON p.pno = c.pno;

```


	
	