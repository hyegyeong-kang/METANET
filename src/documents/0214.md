### SQL

- Transaction
- Index
- Sequence
- View

데이터모델링 

미니프로젝트
- 주제선정 - 요구분석 - 설계 - 구축 - 활용

## Transaction 트랜잭션 -> DML 대상임
- 스프링 서비스에서 처리
=> 전체 일처리가 완결되어야만 의미가 있는 경우
=> 전체 성공 : commit, 실패: rollback (전체작업 취소)

try{
	1. 계좌 출금(본인)
	2. 계좌 입금(상대)

}catch(Exception e){
	rollback();
}
commit();


주문
- 주문목록 등록
- 재고수량 변화
- 결재등록
- 배송등록

```
CREATE TABLE dept_tcl
AS SELECT * FROM dept;


-- 60번 부서로 임의의 데이터 입력
INSERT INTO dept_tcl VALUES(60, 'Database', '서울', 1111);

-- update => 40번 부서의 loc 를 '대구' 로 수정해보자

UPDATE dept_tcl SET loc = '대구' WHERE dno = 40;


rollback; // commit 하면 rollback 해도 돌아가지 않음


```

## Index 

- 오라클 실행과정
-> SQL 파싱 : SQL 구문에 오류가 있는지,SQL 실행 대상 객체(테이블, 뷰) 존재여부 검사
-> SQL 최적화(실행 계획): SQL 이 실행되는데 필요한 비용(cost) 계산
-> SQL 실행 : 세워진 실행 계획을 통해 물리적 실행으로 결과값 도출

 ** 성능이 좋아지고 가장 큰 장점은 일정한 검색속도를 유지하게 해준다. **

주소값들이 다 저장되어잇고 b-tree 구조로 되어있기 때문에 검색속도 유지

- 인덱스를 사용하기 전
: 검색성능이 대용량 데이터에 있어서 현저하게 느림 (데이터를 full scan 하기 때문)
: 검색 속도를 일정하게 보장하지 못한다.

- 인덱스 생성 과정
1. 해당 컬럼에 대한 indexing 으로 데이터값의 rowid 를 생성한다.
2. 인덱스로된 컬럼값과 ROWID 로 구성된 LEAF BlOCKS 가 만들어지고
	그 포인트를 갖는 BRANCH BLOCKS 으로 나뉜다.
	
3. B*Tree 구조로 Balance 로 유지한다. 


- 오라클에서 인덱스를 생성하는 방법
1. PRIMARY KEY, UNIQUE 를 갖는 컬럼은 기본적으로 인덱스가 자동으로 생성된다.
2. CREATE INDEX 인덱스명 


- (오라클에서) 인덱스를 생성해야 하는 경우 
1. WHERE절, JOIN 조건으로 자주 사용하는 컬럼
2. 모든 값이 컬럼 내에서 UNIQUE 
3. 넓은 범위의 값을 가진 컬럼
4. 아주 드물게 존재하는 컬럼


CREATE SEQUENCE board_seq;


```
CREATE INDEX index_name 
on table_name(column_name [,column_name]...)

CREATE UNIQUE INDEX cust_id_idx
on customers_index(cust_id);

```


--퀴즈 > 'title'에 대한 글번호 (seq) 10000번에 대해서 title 값을 'a10000' 을 수정하고 'a10000' 검색 후 실행 계획은 확인 => full scan
인덱스를 생성하고 다시 검색 후 => index scan 

```
UPDATE board SET title = 'a10000' WHERE seq = 10000;

SELECT * FROM board WHERE title = 'a10000';
// FULL SCAN -> 엄청난 비용 


CREATE INDEX board_title_idx
ON board(title); 
// UNIQUE SCAN

DROP INDEX board_title_idx
```

** 인덱스 결론 
-> 빠른 검색 성능(cost 비용 절감)
-> 일정한 검색속도를 유지

